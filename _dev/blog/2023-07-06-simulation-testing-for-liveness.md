#

今月、TigerBeetleのシミュレーターであるVOPRに大きな変更を加えました。シミュレーターを「安全性」モードと新たに追加された「生存性」モードの2つに分けました。

これら2つのモードの違いは何でしょうか？これまで、シミュレーターは一様に障害を注入することで動作していました。つまり、各タイミングでサイコロを振り、一定の確率で健康なレプリカをクラッシュさせたり、ダウンしたレプリカを再起動したり、ネットワークからパケットをドロップしたり、ディスクI/Oの読み書きを破壊したりしていました。

これは、安全性のプロパティをチェックするのに適しています。つまり、ネットワーク、プロセス、ストレージの障害という、多くのシステムが直面する課題にもかかわらず、TigerBeetleが厳密な直列化可能性を保持することを確認します。しかし、このモードでは、運用環境が十分に健康である場合にクラスターが利用可能であるという、すべての生存性のプロパティをチェックするわけではありません。

## 例

3つのレプリカ（A、B、C）からなるクラスターを考えてみましょう。レプリカAがBとCから非対称に分割されているとします。つまり、Aはメッセージを送信できますが、メッセージを受信することはできません。

Aはプライマリからの情報を受信できないため、しばらくするとビューの変更を開始するのが適切だと判断します。この時点で、AがDoViewChangeメッセージをブロードキャストし、BとCがそれに続いてビューの変更を開始すると、クラスターはライブロック状態に陥ります。Aは他のレプリカからの情報を受信できないため、さらにビューの変更をトリガーし続け、クラスターが通常の状態に戻ることなくトランザクションを処理できなくなります。

シミュレーターの「安全性」モードでは、この問題は検出されなかったでしょう。ある確率で、AをBおよびCから分離する非対称パーティションが作成された可能性があります。しかし、このパーティションは一時的なもので、ある時点で修復され、悪質なビュー変更サイクルが中断されます（検出されません）。同様に、「安全性」モードでは、シミュレーターは最終的に各レプリカを再起動することが保証されているため、再起動するまでレプリカが停止する問題に気付かない可能性があります。

この特定の非対称パーティションのバグは以前に修正しましたが、問題を発見するために「多くの目がバグを浅くする」という古い方法に頼っていたことには満足していませんでした。VOPRにこの種のバグを自動的に発見するように指示したいと考え、それが「生存性」モードの導入につながりました。

## VOPRへの教示

我々が保証したい特性は次の通りです：レプリカのクォーラムが利用可能であれば、クラスタ全体も利用可能であるべきです。他のレプリカがアップ状態であったり、ダウン状態であったり、パーティション化されていたりするかもしれませんが、それらがクラスタのコア機能に干渉することはありません。

これをテストするために、クラスタは安全性モードで開始します（これにより、特定のクラスタ状態を確率的に生成できます）。そして、一定時間の障害注入の後、以下の手順で生存性モードに切り替えます：

1. 完全に利用可能なレプリカのクォーラム（コア）を選択します。
2. その時点でダウンしているコアレプリカを再起動します。
3. コアレプリカ間のすべてのネットワークパーティションを修復します。
4. コア以外のレプリカに関連するすべての障害を永続的にします。

この最後の部分が秘訣であり、全体のアイデアの核心です。レプリカが永久にクラッシュした場合、そのレプリカはクラスタの回復に寄与しないが、クラスタ全体は引き続き動作する必要があります。

生存性モードに切り替えた後、クラスタを一定時間実行し、コアのレプリカがすべてのトランザクションを処理できたことを確認します（コア以外のレプリカが遅れていても、それがコアの進行を妨げない限りは問題ありません）。

このセットアップにより、永続的な非対称パーティションをシミュレートすることができるようになりました。

要点をまとめると：

1. 安全性モードで開始し、レプリカをクラッシュさせ、ネットワークとディスクを完全にランダムに操作しながら、厳密な直列化可能性をチェックします。
2. 次に、コアレプリカのセットを選択します。
3. コア内のすべての障害を修復し、同時に他のすべての障害を凍結します。
4. シミュレーションを実行し、コアが収束することを期待します。

それでは、この生存性モードは価値がありましたか？新しいバグが見つかりましたか？はい、新しいバグが見つかりました。

## 共鳴

最も興味深かったのは、私たちの修復アルゴリズムとネットワーク負荷分散との間の共鳴バグでした。

修復とは、ストレージの障害（またはネットワークの障害により最初から受信しなかった）によりレプリカが失ったログエントリを復元するプロセスのことです。私たちの修復はかなり積極的で、レプリカはログエントリを一つずつ修復するのではなく、I/Oを飽和させない範囲で欠落しているエントリを可能な限り多く修復しようとします。

修復するレプリカは、他のレプリカに問題のあるログエントリを再送信するように求めなければなりません。ネットワーク帯域幅を考慮に入れるため、すべての修復クエリをプライマリに向けるのではなく、クラスタ全体に負荷を分散しようとします。具体的には、これはラウンドロビンで実装されました。レプリカはカウンタを維持し、各修復試行時に、repair_counter % replica_countで識別されるレプリカにリクエストを送信し、カウンタをインクリメントします。

生存性モードが示したのは、これら2つのアイデア、つまり、多数のログエントリを並行して修復し、修復リクエストをラウンドロビンするという組み合わせが危険であるということです。具体的には、VOPRはクラスタを操作して、レプリカAがop=5とop=6を欠落しており、レプリカBがop=5を欠落している（しかしop=6は持っている）状況、そしてレプリカCがop=6を欠落している（しかしop=5は持っている）状況に陥ることができました。

したがって、レプリカAは2つのレコードを修復しようとしており、BとCの間で修復リクエストのターゲットを完全に交互にすることで、常にop=5のリクエストをBに、op=6のリクエストをCに向ける、まさに最も不運な方法でした！

生存性モードがなければ、この状況は最終的に解決し、レプリカAが再起動されてリトライカウンタがリセットされるときに検出されずに終わるでしょう。

しかし、新しい生存性モードを使用すると、この状況は無期限に続き、タイムアウト後にレプリカが一部のログエントリをまだ欠落しているときに、シミュレーションが失敗し（そして生存性バグを報告します）。

今日はこれまでです！
